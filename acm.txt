#include <iostream>
#include <vector>
#include <queue>
#include <set>
#include <climits>
#include <algorithm>

using namespace std;

using ll = long long;

struct Edge {
    int to, speed;
};

struct State {
    int vertex, min_speed, max_speed;
    ll energy;
    bool operator<(const State& other) const {
        return energy > other.energy; // Min-heap
    }
};

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    while (cin >> N >> M) {
        // Read edges
        vector<vector<Edge>> adj(N + 1);
        set<int> unique_speeds;
        for (int i = 0; i < M; ++i) {
            int a, b, s;
            cin >> a >> b >> s;
            adj[a].push_back({ b, s });
            adj[b].push_back({ a, s }); // Bidirectional
            unique_speeds.insert(s);
        }
        vector<int> speeds(unique_speeds.begin(), unique_speeds.end());

        // Read start and stop energy
        int start_energy, stop_energy;
        cin >> start_energy >> stop_energy;

        // Read queries
        int K;
        cin >> K;
        vector<pair<int, int>> queries(K);
        for (int i = 0; i < K; ++i) {
            cin >> queries[i].first >> queries[i].second;
        }

        // Process each query
        for (int q = 0; q < K; ++q) {
            int src = queries[q].first;
            int dest = queries[q].second;

            // Initialize distances
            vector<vector<vector<ll>>> dist(
                N + 1,
                vector<vector<ll>>(
                    speeds.size() + 1,
                    vector<ll>(speeds.size() + 1, LLONG_MAX)
                    )
            );
            priority_queue<State> pq;

            // Start state: at source, speed range is [s, s] for some speed s
            for (int i = 0; i < speeds.size(); ++i) {
                dist[src][i][i] = start_energy;
                pq.push({ src, i, i, start_energy });
            }

            ll min_energy = LLONG_MAX;
            while (!pq.empty()) {
                State curr = pq.top();
                pq.pop();

                int u = curr.vertex;
                int min_idx = curr.min_speed;
                int max_idx = curr.max_speed;
                ll energy = curr.energy;

                if (energy > dist[u][min_idx][max_idx]) continue;

                // If at destination, include stop energy
                if (u == dest) {
                    min_energy = min(min_energy, energy + stop_energy);
                    continue;
                }

                // Explore neighbors
                for (const auto& edge : adj[u]) {
                    int v = edge.to;
                    int s = edge.speed;

                    // Find new min and max speed indices
                    int new_min_idx = min_idx;
                    int new_max_idx = max_idx;
                    ll extra_energy = 0;

                    // Find the index of the current speed in speeds
                    int s_idx = lower_bound(speeds.begin(), speeds.end(), s) - speeds.begin();

                    // Check if speed is less than min_speed
                    if (s_idx < min_idx) {
                        extra_energy = speeds[min_idx] - s;
                        new_min_idx = s_idx;
                    }
                    // Check if speed is greater than max_speed
                    else if (s_idx > max_idx) {
                        extra_energy = s - speeds[max_idx];
                        new_max_idx = s_idx;
                    }

                    ll new_energy = energy + extra_energy;

                    if (new_energy < dist[v][new_min_idx][new_max_idx]) {
                        dist[v][new_min_idx][new_max_idx] = new_energy;
                        pq.push({ v, new_min_idx, new_max_idx, new_energy });
                    }
                }
            }

            cout << min_energy << '\n';
        }
    }

    return 0;
}